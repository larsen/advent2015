(in-package #:advent2015)

(defun read-aunts ()
  (let ((sues '())
        (re "Sue (\\d+): (\\w+): (\\d+), (\\w+): (\\d+), (\\w+): (\\d+)"))
    (loop for line in (uiop:read-file-lines (asdf:system-relative-pathname 'advent2015
                                                                           "inputs/day16"))
          do (register-groups-bind ((#'parse-integer idx)
                                    property1
                                    (#'parse-integer property1-value)
                                    property2
                                    (#'parse-integer property2-value)
                                    property3
                                    (#'parse-integer property3-value))
                 (re line)
               (push `((:idx . ,idx)
                       (,property1 . ,property1-value)
                       (,property2 . ,property2-value)
                       (,property3 . ,property3-value))
                     sues))
          finally (return sues))))

(defun is-wrong-aunt-property (property aunt mfcscan-output)
  (and (not (null (assoc property aunt :test #'equal)))
       (not (= (cdr (assoc property mfcscan-output :test #'equal))
               (cdr (assoc property aunt :test #'equal))))))

(defun day16/solution1 ()
  (let* ((aunts (read-aunts))
         (mfcscan-output '(("children" . 3)
                           ("cats" . 7)
                           ("samoyeds" . 2)
                           ("pomeranians" . 3)
                           ("akitas" . 0)
                           ("vizslas" . 0)
                           ("goldfish" . 5)
                           ("trees" . 3)
                           ("cars" . 2)
                           ("perfumes" . 1)))
         (properties (mapcar #'car mfcscan-output)))
    (loop while (> (length aunts) 1)
          do (loop for p in properties
                   do (setf aunts (delete-if (lambda (a)
                                               (is-wrong-aunt-property p a mfcscan-output))
                                             aunts)))
          finally (return (cdr (assoc :idx (first aunts)))))))

(defun is-wrong-aunt-property2 (property aunt mfcscan-output)
  (and (not (null (assoc property aunt :test #'equal)))
       (cond
         ((or (string= property "cats")
              (string= property "trees"))
          (not (< (cdr (assoc property mfcscan-output :test #'equal))
                  (cdr (assoc property aunt :test #'equal)))))
         ((or (string= property "pomeranians")
              (string= property "goldfish"))
          (not (> (cdr (assoc property mfcscan-output :test #'equal))
                            (cdr (assoc property aunt :test #'equal)))))
         (t (not (= (cdr (assoc property mfcscan-output :test #'equal))
                            (cdr (assoc property aunt :test #'equal))))))))

(defun day16/solution2 ()
    (let* ((aunts (read-aunts))
         (mfcscan-output '(("children" . 3)
                           ("cats" . 7)
                           ("samoyeds" . 2)
                           ("pomeranians" . 3)
                           ("akitas" . 0)
                           ("vizslas" . 0)
                           ("goldfish" . 5)
                           ("trees" . 3)
                           ("cars" . 2)
                           ("perfumes" . 1)))
         (properties (mapcar #'car mfcscan-output)))
    (loop while (> (length aunts) 1)
          do (loop for p in properties
                   do (setf aunts (delete-if (lambda (a)
                                               (is-wrong-aunt-property2 p a mfcscan-output))
                                             aunts)))
          finally (return (cdr (assoc :idx (first aunts)))))))
